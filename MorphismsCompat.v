Require Import RelDefinitions.
Require Import RelOperators.
Require Import Relators.
Require Import Coq.Lists.List.

(** ** Resolution process *)

(** Now that we have a way to express and register the monotonicity
  properties of various operators, we want to use them to answer the
  queries generated by setoid rewriting and the [monotonicity] tactic.
  That is, given a relation [R] with existential holes and a term [m],
  use the registered theorems to prove [R m m], instantiating some of
  the existential holes in [R]. All things being equal, we will want
  those instantiations to yield the strongest theorem possible.

  I use the following procedure, implemented below.
    - First, choose an orientation. Since [R m m <-> (flip R) m m],
      we need to consider both of those goals. Furthermore, we need to
      normalize [flip R] so that [flip] is pushed inward and any
      occurence of [flip (flip Q)] is reduced to [Q].
    - Then, if [m] is an applied function, we may want to look for a
      more general [Proper] theorem. So for instance, assuming that
      [Q x x], we can use a theorem of the form [Proper (Q ++> R) f]
      to solve a goal of the form [R (f x) (f x)].
    - Once we've chosen an orientation and a degree of partial
      application, we can finally look for a corresponding [Proper]
      instance.

  We may want to add more phases in the future, for instance to
  generalize the goal using [subrel] instances.

  It is most convenient to embed this process into the typeclass
  resolution mechanism. In particular, nondeterministic choices come
  in handy. But we don't want these resolution steps to be applied
  arbitrarily. In order to enforce the sequential aspect, we use the
  proxy class [ProperQuery], which is parametrized by a list of
  processing phases remaining. *)

Inductive processing_phase :=
  | proper_orientation
  | proper_partial_app
  | proper_partial_arg
  | proper_subrel.

Class ProperQuery (φs: list processing_phase) {A} (R: rel A A) (m: A) :=
  proper_query_outcome: Proper R m.

(** The different [processing_phase]s will peel themselves off the
  list and generate subgoals to be handled by the next phase.
  Ultimately the list becomes empty, and we look for a regular
  instance of [Proper]. *)

Global Instance proper_query_finalize {A} (R: rel A A) (m: A):
  Proper R m ->
  ProperQuery nil R m.
Proof.
  tauto.
Qed.

(** ** Flipping [Proper] goals *)

(** Instances of this class can be used to indicate how [flip] is to
  be pushed to the inside of given relation operators. *)

Class FlipsTo {A B} (R: rel A B) (R': rel B A) :=
  flips_to: eqrel (flip R) R'.

Arguments FlipsTo {_ _} R%signature R'%signature.

(** Catch-all, default instance. *)

Instance atom_flipsto {A B} (R: rel A B):
  FlipsTo R (flip R) | 10.
Proof.
  firstorder.
Qed.

(** Flipping twice. This instance is also used when the first argument
  is an existential variable, so that the resulting relation is itself
  as general as possible. *)

Instance flip_flipsto {A B} (R: rel A B):
  FlipsTo (flip R) R.
Proof.
  firstorder.
Qed.

(** Symmetric relations flip to themselves. *)

Instance:
  forall {A} (R: rel A A) (HR: Symmetric R),
    FlipsTo R R.
Proof.
  firstorder.
Qed.

(** Instances for basic relators. *)

Instance arrow_flipsto {A1 A2 B1 B2} (RA: rel A1 A2) (RB: rel B1 B2) RA' RB':
  FlipsTo RA RA' ->
  FlipsTo RB RB' ->
  FlipsTo (RA ++> RB) (RA' ++> RB').
Proof.
  unfold FlipsTo, flip.
  firstorder.
Qed.

(** The [proper_orientation] phase causes both orientations to be tried. *)

Global Instance proper_orientation_direct φs {A} (R: rel A A) (m: A):
  ProperQuery φs R m ->
  ProperQuery (proper_orientation::φs) R m.
Proof.
  tauto.
Qed.

Lemma proper_orientation_flip φs {A} (R R': rel A A) (m: A):
  FlipsTo R R' ->
  ProperQuery φs R' m ->
  ProperQuery (proper_orientation::φs) R m.
Proof.
  firstorder.
Qed.

(** For [proper_orientation_flip] above, we only want to use the
  first instance of [FlipsTo] found. *)

Ltac proper_orientation_flip :=
  lazymatch goal with
    | |- @ProperQuery _ ?A ?R ?m =>
      let Rv := fresh in evar (Rv: rel A A);
      let R' := eval red in Rv in clear Rv;
      let H := fresh in
      assert (H: FlipsTo R R') by typeclasses eauto;
      eapply (@proper_orientation_flip _ A R R' m H);
      clear H
  end.

Hint Extern 2 (ProperQuery (proper_orientation::_) _ _) =>
  proper_orientation_flip : typeclass_instances.

(** ** Partial applications *)

(** In many contexts, we need to show [Proper Rg (op a₁ … aₖ … aₙ)],
  but what we acually have is a more general instance of
  [Proper R (op a₁ … aₖ)]. If [R] is built up from reflexive relations
  (or at least, relations for which the corresponding [aᵢ] is a proper
  element), then the former can be obtained from the latter.

  In [Coq.Classes.Morphisms], this is handled by [partial_application_tactic],
  which applies [Reflexive_partial_app_morphism] on a goal of the form
  [Proper R' (op x)] to obtain the new goal [Proper (R ==> R') op],
  with [R] an existential variable to be unified against the [Proper]
  instances of this form that are eventually found. However, we cannot
  naively extend this strategy to obtain goals of the form
  [Proper (forall_rel R) op]. We would need the many more existential
  variables [V : Type], [E : V -> V -> Type], [e : E x x],
  [FV : V -> Type], [R : forall v1 v2, E v1 v2 -> rel (FV v1) (FV v2)],
  and what's more we would have to perform the higher-order
  unification of [R'] — likely just some existential variable at this
  point — against [?R ?v ?v ?e]. #<em>#Maybe#</em># this could be achieved
  by going through another existential variable within the context of
  a lambda abstraction such that [R] ≐ [(fun v1 v2 e => ?)] (if that
  is even possible). However the resulting unification process would
  be rather messy and undebuggable.

  Instead, we start with whatever instances of [Proper (forall_rel R) op]
  we can find, then try to unify [R'] against the corresponding
  mostly-concrete [R x x ?e]. To this end, we use the following
  intermediate class. *)

Class ProperApplies A (B: A -> Type) R (a: A) R' (m: forall a, B a) :=
  proper_applies : Proper R m -> Proper R' (m a).

Ltac proper_applies :=
  let H := fresh in
  unfold ProperApplies, ProperDef;
  intro H;
  eapply H;
  eapply (@proper_query_outcome (proper_partial_arg::nil)).

Hint Extern 1 (ProperApplies _ _ _ _ _ _) =>
  proper_applies : typeclass_instances.

(** The processing phase [proper_partial_arg] is used for proving that
  a given argument can be applied. It is our version of
  [Morphisms.ProperProxy]. *)

Instance proper_partial_arg_eq φs {A} (m: A):
  ProperQuery (proper_partial_arg::φs) eq m.
Proof.
  firstorder.
Qed.

Instance proper_partial_arg_reflexive φs {A} (R: rel A A) (m: A):
  Reflexive R ->
  ProperQuery (proper_partial_arg::φs) R m.
Proof.
  firstorder.
Qed.

Instance proper_partial_arg_default φs {A} (R: rel A A) (m: A):
  NotEvar R ->
  ProperQuery φs R m ->
  ProperQuery (proper_partial_arg::φs) R m.
Proof.
  firstorder.
Qed.

(** The [proper_partial_app] processing phase consists in using
  [proper_applies] an arbitrary number of times. TODO: we may want to
  use the [Params] class to limit the resulting search space to only
  one possibility instead. *)

Global Instance proper_partial_app_bail φs {A} (R: rel A A) (m: A):
  ProperQuery φs R m ->
  ProperQuery (proper_partial_app::φs) R m.
Proof.
  tauto.
Qed.

Lemma proper_partial_app_arg φs {A} (B: A -> Type) R a R' m:
  @ProperQuery (proper_partial_app::φs) (forall a, B a) R m ->
  ProperApplies A B R a R' m ->
  @ProperQuery (proper_partial_app::φs) (B a) R' (m a).
Proof.
  firstorder.
Qed.

(** When using [proper_partial_app_arg], the unification of the goal
  against the subterm [(B a)] is problematic, because usually the type
  will be an arbitrary expression where [a] appears freely. Therefore,
  we first need to put the goal in the right form. The tactic
  [dependent_type_of] recovers the type of a term that can be applied,
  as a function of its first argument. *)

Ltac dependent_type_of f arg T :=
  let A := type of arg in
  let x := fresh "x" in evar (x : A);
  let fx := fresh "fx" in set (fx := f x);
  pattern x in fx;
  lazymatch type of fx with ?TT _ => set (T := TT) end;
  let y := eval red in x in unify y arg;
  subst x fx.

Ltac proper_partial_app_arg :=
  lazymatch goal with
    | |- ProperQuery (proper_partial_app::?φs) ?R (?op ?arg) =>
      let T := fresh "T" in dependent_type_of op arg T;
      eapply (proper_partial_app_arg φs T _ arg R op);
      subst T
  end.

Hint Extern 2 (ProperQuery (proper_partial_app::_) _ _) =>
  proper_partial_app_arg : typeclass_instances.

(** ** Using [subrel] *)

(** The processing step [proper_subrel] causes the search to be
  extended to subrelations. The order of the [ProperQuery] and
  [subrel] arguments is pretty critical: first, we go on and try to
  find /any/ instance of [Proper] for [m]; then, we check to see if
  the associated relation is a subrelation of the target one. *)

Global Instance do_proper_subrel {A} φs (R1 R2: rel A A) (m: A):
  ProperQuery φs R1 m ->
  subrel R1 R2 ->
  ProperQuery (proper_subrel::φs) R2 m.
Proof.
  firstorder.
Qed.

(** ** Compatibility with setoid rewriting *)

(** So far our system is isolated from the similar constructions in
  [Coq.Classes.Morphisms]. The [convert_proper] tactic permits a
  controlled interaction between them. It converts a [Morphisms.Proper]
  goal into a [ProperQuery] one, replacing legacy relators such as
  [respectful] with their more general counterparts defined here.
  This allows the setoid rewriting mechanism to use the morphisms we
  define.

  Note that in the query we use, [proper_subrel] needs to happen
  before [proper_partial_app], otherwise [proper_partial_app_arg]
  might replace the target relation with an existential variable,
  breaking the subrelation search. Possibly, another solution would be
  to change the order of arguments in [proper_partial_app_arg] so that
  the [ProperApplies] subgoal is solved first. *)

Notation rewrite_proper_query :=
  (proper_orientation :: proper_subrel :: proper_partial_app :: nil)
  (only parsing).

Ltac convert_proper :=
  repeat
    match goal with
      | |- appcontext C[respectful ?R1 ?R2] =>
        let T' := context C[R1 ==> R2] in change T'
      | |- appcontext C[forall_relation ?R] =>
        let T' := context C[∀ -, R] in change T'
      | |- Morphisms.Proper ?R ?m =>
        change (ProperQuery rewrite_proper_query R m)
    end.

(** We want [convert_proper] to be used for the initial [Proper] goal,
  but we're not really interested in having it applied to the subgoals
  generated by the original process in [Coq.Classes.Morphisms], since
  we have our own. The following tactic attempts to detect and reject
  cases where some work has already been done. *)

Ltac use_convert_proper :=
  match goal with
    | _ : normalization_done |- _ =>
      fail 1
    | H : apply_subrelation |- _ =>
      clear H;
      progress convert_proper
  end.

Hint Extern 1 (Morphisms.Proper _ _) =>
  use_convert_proper : typeclass_instances.

(** The monotonicity of transitive relations is sometimes needed to
  solve the goals generated by setoid rewriting. *)

Instance transitive_proper {A} (R: rel A A):
  Transitive R ->
  Proper (R --> R ++> impl) R.
Proof.
  firstorder.
Qed.
